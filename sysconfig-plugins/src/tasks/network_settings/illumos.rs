use std::fs;
use std::io::{self, Write};
use std::os::unix::ffi::OsStrExt;
use std::path::Path;
use tracing::{info, warn};

pub fn apply_hostname(hostname: &str, dry_run: bool) -> io::Result<bool> {
    let mut changed = false;

    if dry_run {
        info!("DRY-RUN: Checking hostname configuration...");
    }

    // Persisted hostname on illumos is /etc/nodename
    let persist_path = Path::new("/etc/nodename");
    let desired_file = format!("{}\n", hostname);
    let current_file = match fs::read_to_string(persist_path) {
        Ok(content) => content,
        Err(e) => {
            if dry_run {
                info!("DRY-RUN: Could not read {} ({}), assuming empty", persist_path.display(), e);
                String::new()
            } else {
                warn!("Could not read {} ({}), assuming empty", persist_path.display(), e);
                String::new()
            }
        }
    };
    if current_file != desired_file {
        changed = true;
        if dry_run {
            info!(
                "DRY-RUN: Would write hostname '{}' to {}",
                hostname,
                persist_path.display()
            );
            info!("DRY-RUN:   Current content: {:?}", current_file.trim());
            info!("DRY-RUN:   New content: {:?}", hostname);
        } else {
            atomic_write(persist_path, desired_file.as_bytes())?;
            info!(
                "Updated {} with hostname '{}'",
                persist_path.display(),
                hostname
            );
        }
    }

    // Runtime hostname via sethostname(2)
    let current_runtime = match get_runtime_hostname() {
        Ok(hostname) => hostname,
        Err(e) => {
            if dry_run {
                info!("DRY-RUN: Could not get current runtime hostname ({}), assuming empty", e);
                String::new()
            } else {
                warn!("Could not get current runtime hostname ({}), assuming empty", e);
                String::new()
            }
        }
    };
    if current_runtime != hostname {
        changed = true;
        if dry_run {
            info!(
                "DRY-RUN: Would set runtime hostname from '{}' to '{}'",
                current_runtime, hostname
            );
            info!("DRY-RUN:   Would call: sethostname(\"{}\")", hostname);
        } else {
            set_runtime_hostname(hostname)?;
            info!("Set runtime hostname to '{}'", hostname);
        }
    }

    if dry_run && !changed {
        info!(
            "DRY-RUN: Hostname '{}' is already configured correctly",
            hostname
        );
    }

    Ok(changed)
}

pub fn apply_dns(nameservers: &[String], search: &[String], dry_run: bool) -> io::Result<bool> {
    let path = Path::new("/etc/resolv.conf");

    if dry_run {
        info!("DRY-RUN: Checking DNS configuration...");
    }

    let mut content = String::new();
    content.push_str("# Generated by sysconfig-plugins network_settings (illumos)\n");
    if !search.is_empty() {
        content.push_str("search ");
        content.push_str(&search.join(" "));
        content.push('\n');
    }
    for ns in nameservers {
        content.push_str("nameserver ");
        content.push_str(ns);
        content.push('\n');
    }

    let current = fs::read_to_string(path).unwrap_or_default();
    if current == content {
        if dry_run {
            info!("DRY-RUN: DNS configuration is already up to date");
        }
        return Ok(false);
    }

    if dry_run {
        info!("DRY-RUN: Would update {} with:", path.display());
        info!("DRY-RUN:   Nameservers: {:?}", nameservers);
        info!("DRY-RUN:   Search domains: {:?}", search);
        info!("DRY-RUN: New content would be:");
        for line in content.lines() {
            info!("DRY-RUN:   {}", line);
        }
        if let Ok(current_lines) = fs::read_to_string(path) {
            info!("DRY-RUN: Current content is:");
            for line in current_lines.lines().take(10) {
                info!("DRY-RUN:   {}", line);
            }
            if current_lines.lines().count() > 10 {
                info!(
                    "DRY-RUN:   ... ({} more lines)",
                    current_lines.lines().count() - 10
                );
            }
        } else {
            info!("DRY-RUN: Current file does not exist or is not readable");
        }
    } else {
        atomic_write(path, content.as_bytes())?;
        info!(
            "Updated {} with {} nameservers and {} search domains",
            path.display(),
            nameservers.len(),
            search.len()
        );
    }
    Ok(true)
}

fn atomic_write(path: &Path, data: &[u8]) -> io::Result<()> {
    if let Some(dir) = path.parent() {
        fs::create_dir_all(dir)?;
    }
    let tmp = path.with_extension("tmp");
    {
        let mut f = fs::File::create(&tmp)?;
        f.write_all(data)?;
        f.sync_all()?;
    }
    fs::rename(tmp, path)?;
    Ok(())
}

fn get_runtime_hostname() -> io::Result<String> {
    let mut buf = vec![0u8; 256];
    let rc = unsafe { libc::gethostname(buf.as_mut_ptr() as *mut libc::c_char, buf.len()) };
    if rc != 0 {
        return Err(io::Error::last_os_error());
    }
    if let Some(pos) = buf.iter().position(|&b| b == 0) {
        buf.truncate(pos);
    }
    Ok(String::from_utf8_lossy(&buf).to_string())
}

fn set_runtime_hostname(hostname: &str) -> io::Result<()> {
    let bytes = std::ffi::OsStr::new(hostname).as_bytes();
    let rc = unsafe { libc::sethostname(bytes.as_ptr() as *const libc::c_char, bytes.len()) };
    if rc != 0 {
        return Err(io::Error::last_os_error());
    }
    Ok(())
}
