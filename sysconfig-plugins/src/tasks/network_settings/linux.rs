use std::fs;
use std::io::{self, Write};
use std::os::unix::ffi::OsStrExt;
use std::path::Path;
use std::process::Command;

pub fn apply_hostname(hostname: &str, dry_run: bool) -> io::Result<bool> {
    let mut changed = false;

    // Persisted hostname file on most Linux distros
    let persist_path = Path::new("/etc/hostname");
    let desired_file = format!("{}\n", hostname);
    let current_file = fs::read_to_string(persist_path).unwrap_or_default();
    if current_file != desired_file {
        changed = true;
        if !dry_run {
            atomic_write(persist_path, desired_file.as_bytes())?;
        }
    }

    // Runtime hostname via sethostname(2)
    let current_runtime = get_runtime_hostname().unwrap_or_default();
    if current_runtime != hostname {
        changed = true;
        if !dry_run {
            set_runtime_hostname(hostname)?;
        }
    }

    Ok(changed)
}

pub fn apply_dns(nameservers: &[String], search: &[String], dry_run: bool) -> io::Result<bool> {
    let path = Path::new("/etc/resolv.conf");
    let mut content = String::new();
    content.push_str("# Generated by sysconfig-plugins network_settings (Linux)\n");
    if !search.is_empty() {
        content.push_str("search ");
        content.push_str(&search.join(" "));
        content.push('\n');
    }
    for ns in nameservers {
        content.push_str("nameserver ");
        content.push_str(ns);
        content.push('\n');
    }

    let current = fs::read_to_string(path).unwrap_or_default();
    if current == content {
        return Ok(false);
    }
    if !dry_run {
        atomic_write(path, content.as_bytes())?;
    }
    Ok(true)
}

pub fn flush_dns_cache() -> io::Result<()> {
    // Best effort: systemd-resolved
    let _ = Command::new("resolvectl").arg("flush-caches").status();
    // nscd
    let _ = Command::new("nscd").arg("-i").arg("hosts").status();
    Ok(())
}

fn atomic_write(path: &Path, data: &[u8]) -> io::Result<()> {
    if let Some(dir) = path.parent() { fs::create_dir_all(dir)?; }
    let tmp = path.with_extension("tmp");
    {
        let mut f = fs::File::create(&tmp)?;
        f.write_all(data)?;
        f.sync_all()?;
    }
    fs::rename(tmp, path)?;
    Ok(())
}

fn get_runtime_hostname() -> io::Result<String> {
    // 64 should be enough; Linux allows up to 64 for hostnames (typically 64)
    let mut buf = vec![0u8; 256];
    let rc = unsafe { libc::gethostname(buf.as_mut_ptr() as *mut libc::c_char, buf.len()) };
    if rc != 0 {
        return Err(io::Error::last_os_error());
    }
    // C string may not be null-terminated if exactly full; find first 0
    if let Some(pos) = buf.iter().position(|&b| b == 0) { buf.truncate(pos); }
    Ok(String::from_utf8_lossy(&buf).to_string())
}

fn set_runtime_hostname(hostname: &str) -> io::Result<()> {
    let bytes = std::ffi::OsStr::new(hostname).as_bytes();
    let rc = unsafe { libc::sethostname(bytes.as_ptr() as *const libc::c_char, bytes.len()) };
    if rc != 0 { return Err(io::Error::last_os_error()); }
    Ok(())
}
