use std::fs;
use std::io::{self, Write};
use std::os::unix::ffi::OsStrExt;
use std::path::Path;

pub fn apply_hostname(hostname: &str, dry_run: bool) -> io::Result<bool> {
    let mut changed = false;

    // Persisted hostname on FreeBSD is set in /etc/rc.conf as hostname="..."
    let rcconf = Path::new("/etc/rc.conf");
    let mut lines = fs::read_to_string(rcconf).unwrap_or_default();
    let desired_line = format!("hostname=\"{}\"\n", hostname);
    let mut new_lines = String::new();
    let mut found = false;

    if !lines.is_empty() {
        for line in lines.lines() {
            if line.trim_start().starts_with("hostname=") {
                found = true;
                new_lines.push_str(&desired_line);
            } else {
                new_lines.push_str(line);
                new_lines.push('\n');
            }
        }
    }
    if !found {
        new_lines = lines;
        new_lines.push_str(&desired_line);
    }

    if new_lines != lines {
        changed = true;
        if !dry_run {
            atomic_write(rcconf, new_lines.as_bytes())?;
        }
    }

    // Runtime hostname via sethostname(3)
    let current_runtime = get_runtime_hostname().unwrap_or_default();
    if current_runtime != hostname {
        changed = true;
        if !dry_run {
            set_runtime_hostname(hostname)?;
        }
    }

    Ok(changed)
}

pub fn apply_dns(nameservers: &[String], search: &[String], dry_run: bool) -> io::Result<bool> {
    let path = Path::new("/etc/resolv.conf");
    let mut content = String::new();
    content.push_str("# Generated by sysconfig-plugins network_settings (FreeBSD)\n");
    if !search.is_empty() {
        content.push_str("search ");
        content.push_str(&search.join(" "));
        content.push('\n');
    }
    for ns in nameservers {
        content.push_str("nameserver ");
        content.push_str(ns);
        content.push('\n');
    }

    let current = fs::read_to_string(path).unwrap_or_default();
    if current == content {
        return Ok(false);
    }
    if !dry_run {
        atomic_write(path, content.as_bytes())?;
    }
    Ok(true)
}

fn atomic_write(path: &Path, data: &[u8]) -> io::Result<()> {
    if let Some(dir) = path.parent() { fs::create_dir_all(dir)?; }
    let tmp = path.with_extension("tmp");
    {
        let mut f = fs::File::create(&tmp)?;
        f.write_all(data)?;
        f.sync_all()?;
    }
    fs::rename(tmp, path)?;
    Ok(())
}

fn get_runtime_hostname() -> io::Result<String> {
    let mut buf = vec![0u8; 256];
    let rc = unsafe { libc::gethostname(buf.as_mut_ptr() as *mut libc::c_char, buf.len()) };
    if rc != 0 {
        return Err(io::Error::last_os_error());
    }
    if let Some(pos) = buf.iter().position(|&b| b == 0) { buf.truncate(pos); }
    Ok(String::from_utf8_lossy(&buf).to_string())
}

fn set_runtime_hostname(hostname: &str) -> io::Result<()> {
    let bytes = std::ffi::OsStr::new(hostname).as_bytes();
    let rc = unsafe { libc::sethostname(bytes.as_ptr() as *const libc::c_char, bytes.len()) };
    if rc != 0 { return Err(io::Error::last_os_error()); }
    Ok(())
}
